
 /**
  * This template file was generated by Dynatrace client.
  * The Dynatrace community portal can be found here: http://community.dynatrace.com/
  * For information how to publish a plugin please visit https://community.dynatrace.com/community/display/DL/How+to+add+a+new+plugin/
  **/ 

package com.dynatrace.community.monitor;

import com.dynatrace.diagnostics.pdk.*;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.URL;
import java.util.Collection;
import java.util.HashMap;
import java.util.logging.Logger;
import com.sun.net.httpserver.*;

public class GenericMeasureMonitorPlugin implements Monitor {

	private static final Logger log = Logger.getLogger(GenericMeasureMonitorPlugin.class.getName());

	private DynaTraceHttpHandler dynatraceHttpHandler = null;
	private HttpServer httpServerListener = null;
	private HttpContext httpContext = null;
	private long restPort = 4000;
	private String restURL = "/genericmonitor";
	private boolean isTestMode = false;
	
	/**
	 * You can also run this from the command line to TEST this plugin
	 * @param args
	 * @throws Exception
	 */
	public static void main(String[] args) throws Exception {
		boolean bTestPlugin = true;
		boolean bTestURLParsing = false; 
		
		GenericMeasureMonitorPlugin plugin = new GenericMeasureMonitorPlugin();
		
		if(bTestURLParsing) {
			GenericMeasureMonitorPlugin.DynaTraceHttpHandler httpHandler = plugin.createHttpHandler();
			
			httpHandler.processRequestParameter("Timer1:Response Time=123;Timer2:Response Time=323");
			httpHandler.processRequestParameter("Timer1:Response Time=123,Bytes=234,Latency=332");
			httpHandler.processRequestParameter("Response Time=123;Latency=333");
			httpHandler.processRequestParameter("Response Time=123");
		}
		
		
		// Testing Plugin itself
		if(bTestPlugin) {
			plugin.setup(null);

			System.out.println("Sending a request to the listener");
			URL u = new URL("http://localhost:4000/genericmonitor?Timer1:Response%20Time=123;Timer2:Response%20Time=323");
			InputStream iStream = u.openConnection().getInputStream();
			String nextLine = new BufferedReader(new InputStreamReader(iStream)).readLine();
			iStream.close();
			System.out.println("Got this back from the listener: " + nextLine);
						
			System.out.println("Press any key to close ...!");
	        nextLine = new BufferedReader(new InputStreamReader(System.in)).readLine();
			
			plugin.execute(null);
			plugin.teardown(null);
		}
	}

	/**
	 * Initializes the Plugin. This method is called in the following cases:
	 * <ul>
	 * <li>before <tt>execute</tt> is called the first time for this
	 * scheduled Plugin</li>
	 * <li>before the next <tt>execute</tt> if <tt>teardown</tt> was called
	 * after the last execution</li>
	 * </ul>
	 * <p>
	 * If the returned status is <tt>null</tt> or the status code is a
	 * non-success code then {@link Plugin#teardown() teardown()} will be called
	 * next.
	 * <p>
	 * Resources like sockets or files can be opened in this method.
	 * @param env
	 *            the configured <tt>MonitorEnvironment</tt> for this Plugin;
	 *            contains subscribed measures, but <b>measurements will be
	 *            discarded</b>
	 * @see Plugin#teardown()
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status setup(MonitorEnvironment env) throws Exception {
		String resultMessage = "";
		if(env != null) restPort = env.getConfigLong("myRESTPort");
		if(env != null) restURL = env.getConfigString("myRESTURLEndpoint");
		
		// Endpoint MUST start with a /
		if(!restURL.startsWith("/")) restURL = "/" + restURL;
		
		log.info("setup on " + restURL + " on port " + String.valueOf((int)restPort));
		
		// lets start our listener
		try {
			httpServerListener = HttpServer.create(new InetSocketAddress((int)restPort), 0);
			dynatraceHttpHandler = new DynaTraceHttpHandler();
			httpContext = httpServerListener.createContext(restURL, dynatraceHttpHandler);
			httpServerListener.setExecutor(null);
			httpServerListener.start();
		}catch(Exception e) {
			if(httpServerListener != null) {
				// try to close the connection
				try {					
					httpServerListener.stop(0);
					httpServerListener.removeContext(httpContext);
				} catch(Exception e1) {}
				finally {
					httpContext = null;
					httpServerListener = null;					
				}
			}
			
			return new Status(Status.StatusCode.ErrorInternalConfigurationProblem, "Error during starting HTTP Listener on :" + String.valueOf((int)restPort) + restURL, e.getMessage());
		}
		
		// If the HOST has the name "TEST" we run an internal test to deliver some test data
		// this is good when you develop the plugin and test it in the Dynatrace Client
		isTestMode = ((env == null) || env.getHost().getAddress().equals("TEST"));
		
		if(isTestMode) {
			dynatraceHttpHandler.addMeasure("Timer 1").addSplitMeasure("Response Time", 123.0);
			dynatraceHttpHandler.addMeasure("Timer 1").addSplitMeasure("Exec Time", 100.0);
			dynatraceHttpHandler.addMeasure("Timer 1").addSplitMeasure("Latency ", 200.0);
			dynatraceHttpHandler.addMeasure("Timer 2").addSplitMeasure("Response Time", 145.0);
			dynatraceHttpHandler.addMeasure("Response Time", 324.0);
			
			resultMessage += "TEST MODE: Added 3 Measures";
		}
		
		return new Status(Status.StatusCode.Success, resultMessage);
	}

	/**
	 * Executes the Monitor Plugin to retrieve subscribed measures and store
	 * measurements.
	 *
	 * <p>
	 * This method is called at the scheduled intervals. If the Plugin execution
	 * takes longer than the schedule interval, subsequent calls to
	 * {@link #execute(MonitorEnvironment)} will be skipped until this method
	 * returns. After the execution duration exceeds the schedule timeout,
	 * {@link TaskEnvironment#isStopped()} will return <tt>true</tt>. In this
	 * case execution should be stopped as soon as possible. If the Plugin
	 * ignores {@link TaskEnvironment#isStopped()} or fails to stop execution in
	 * a reasonable timeframe, the execution thread will be stopped ungracefully
	 * which might lead to resource leaks!
	 *
	 * @param env
	 *            a <tt>MonitorEnvironment</tt> object that contains the
	 *            Plugin configuration and subscribed measures. These
	*            <tt>MonitorMeasure</tt>s can be used to store measurements.
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status execute(MonitorEnvironment env) throws Exception {
		if(env == null) return new Status(Status.StatusCode.Uninitialized);
		
		try {
			Collection<MonitorMeasure> monitorMeasures = env.getMonitorMeasures("Generic Metric Group", "Numeric Metric");
			for (MonitorMeasure subscribedMonitorMeasure : monitorMeasures) {
				Object[] itemObjects = dynatraceHttpHandler.genericMeasures.values().toArray();
				dynatraceHttpHandler.genericMeasures.clear();
				
				for(Object itemObject : itemObjects) {
					DynaTraceHttpHandler.GenericAggregatedMeasure masterMeasure = (DynaTraceHttpHandler.GenericAggregatedMeasure)itemObject;
					
					if(masterMeasure.hasValue()) {
						subscribedMonitorMeasure.setValue(masterMeasure.avg);
					}
					
					Collection<DynaTraceHttpHandler.GenericAggregatedMeasure> splitMeasures = masterMeasure.getSplitMeasures();
					if(splitMeasures != null) {
						for(DynaTraceHttpHandler.GenericAggregatedMeasure splitMeasure : splitMeasures) {
							if(splitMeasure.hasValue()) {
								MonitorMeasure dynamicMeasure = env.createDynamicMeasure(subscribedMonitorMeasure, splitMeasure.measureName, masterMeasure.measureName);
								dynamicMeasure.setValue(splitMeasure.avg);								
							}
						}
					}
				}
			}
		} 
		catch(Exception e) {
			return new Status(Status.StatusCode.ErrorInternal, e.getMessage());
		}
		finally
		{
			if(isTestMode) teardown(env);			
		}
		
		
		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Shuts the Plugin down and frees resources. This method is called in the
	 * following cases:
	 * <ul>
	 * <li>the <tt>setup</tt> method failed</li>
	 * <li>the Plugin configuration has changed</li>
	 * <li>the execution duration of the Plugin exceeded the schedule timeout</li>
	 * <li>the schedule associated with this Plugin was removed</li>
	 * </ul>
	 *
	 * <p>
	 * The Plugin methods <tt>setup</tt>, <tt>execute</tt> and
	 * <tt>teardown</tt> are called on different threads, but they are called
	 * sequentially. This means that the execution of these methods does not
	 * overlap, they are executed one after the other.
	 *
	 * <p>
	 * Examples:
	 * <ul>
	 * <li><tt>setup</tt> (failed) -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, configuration changes, <tt>execute</tt>
	 * ends -&gt; <tt>teardown</tt><br>
	 * on next schedule interval: <tt>setup</tt> -&gt; <tt>execute</tt> ...</li>
	 * <li><tt>execute</tt> starts, execution duration timeout,
	 * <tt>execute</tt> stops -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, <tt>execute</tt> ends, schedule is
	 * removed -&gt; <tt>teardown</tt></li>
	 * </ul>
	 * Failed means that either an unhandled exception is thrown or the status
	 * returned by the method contains a non-success code.
	 *
	 *
	 * <p>
	 * All by the Plugin allocated resources should be freed in this method.
	 * Examples are opened sockets or files.
	 *
	 * @see Monitor#setup(MonitorEnvironment)
	 */	@Override
	public void teardown(MonitorEnvironment env) throws Exception {
		 if(httpServerListener != null) {
			 if(httpContext != null) httpServerListener.removeContext(httpContext);
			 httpServerListener.stop(0);
		 }
	}
	 
	public DynaTraceHttpHandler createHttpHandler() {
		return new DynaTraceHttpHandler();
	} 
	 	
	public class DynaTraceHttpHandler implements HttpHandler {
		
		public class GenericAggregatedMeasure
		{
			public String measureName;
			public int count;
			public double min, max, avg;
			public HashMap<String, GenericAggregatedMeasure> splitMeasures = null;

			public GenericAggregatedMeasure(String name) {
				this.measureName = name;
				this.count = 0;
				this.min = this.max = this.avg = 0.0;
			}
			
			public void addValue(double value) {
				avg = (avg*count + value);
				count++;
				if(avg != 0) avg = avg / count;
				if(value < min || (count == 1)) min = value;
				if(value > max || (count == 1)) max = value;
			}
			
			public void cleanValue() {
				count = 0;
				if(splitMeasures != null) {
					for(GenericAggregatedMeasure splitMeasure : splitMeasures.values()) {
						splitMeasure.cleanValue();
					}
				}
			}
			
			public boolean hasValue() {
				return (count > 0);
			}
			
			public GenericAggregatedMeasure addSplitMeasure(String name, double value) {
				GenericAggregatedMeasure splitMeasure = null;
				if(splitMeasures == null) {
					splitMeasures = new HashMap<String, GenericAggregatedMeasure>();
				} else {
					splitMeasure = splitMeasures.get(name);
				}
				
				if(splitMeasure == null) {
					splitMeasure = new GenericAggregatedMeasure(name);
					splitMeasures.put(name, splitMeasure);
				}
				
				splitMeasure.addValue(value);
				return splitMeasure;
			}
			
			public Collection<GenericAggregatedMeasure> getSplitMeasures() {
				return splitMeasures == null ? null : splitMeasures.values();
			}
			
			@Override
			public String toString() {
				StringBuffer sb = new StringBuffer();
				sb.append(String.format("%s: CNT=%d, MIN=%.2f, AVG=%.2f, MAX=%.2f", measureName, count, min, avg, max));
				if(splitMeasures != null) {
					for(GenericAggregatedMeasure splitMeasure : splitMeasures.values()) {
						sb.append("\n -- ");
						sb.append(splitMeasure.toString());
					}
				}
				return sb.toString();
			}
		}

		public HashMap<String, GenericAggregatedMeasure> genericMeasures = new HashMap<String, GenericAggregatedMeasure>();
		
		public GenericAggregatedMeasure addMeasure(String name) {
			GenericAggregatedMeasure measure = genericMeasures.get(name);
			if(measure == null) {
				measure = new GenericAggregatedMeasure(name);
				genericMeasures.put(name, measure);
			}
			return measure;
		}
		
		public GenericAggregatedMeasure addMeasure(String name, double doubleValue) {
			GenericAggregatedMeasure measure = addMeasure(name);
			measure.addValue(doubleValue);
			return measure;
		}		
				
        @Override
        public void handle(HttpExchange t) throws IOException {
            String response = "NO DATA!";
            String request = "";
            
            // Get Data either from Query or POST Body
            if(t.getRequestMethod().compareToIgnoreCase("GET") == 0) {
            	request = t.getRequestURI().getQuery();
            } else if(t.getRequestMethod().compareToIgnoreCase("POST") == 0) {
            	InputStreamReader iReader = new InputStreamReader(t.getRequestBody());
            	BufferedReader br = new BufferedReader(iReader);
            	StringBuilder sb = new StringBuilder();
            	String line = null;
            	
            	while((line = br.readLine()) != null) {sb.append(line);}
            	br.close();iReader.close();
            	
            	request = sb.toString();
            }
            
            // process the request string	            
            response = processRequestParameter(request);
            
            // send the response back
            t.sendResponseHeaders(200, response.length());
            OutputStream os = t.getResponseBody();
            os.write(response.getBytes());
            os.close();
        }

        /**
         * 	// sample URL
            /genericmonitor?Timer1:Response Time=123;Timer2:Response Time=323
            /genericmonitor?Timer1:Response Time=123,Bytes=234,Latency=332;
            /genericmonitor?Response Time=123;Latency=333
            /genericmonitor?Response Time=123
         * @param request
         * @return
         */
		public String processRequestParameter(String request) {
			String response = "NO DATA";
	        String[] valuePairs = request.split(";");
	            
            for(String valuePair : valuePairs) {
            	// lets see if we have a "master" measure name
            	int colonIx = valuePair.indexOf(":");
            	String masterMeasureName = null;
            	GenericAggregatedMeasure masterMeasure = null;
            	if(colonIx > 0) {
            		masterMeasureName = valuePair.substring(0, colonIx);
            		valuePair = valuePair.substring(colonIx + 1);
            		
            		masterMeasure = addMeasure(masterMeasureName);
            	}
            			            	
            	// there might be multiple measures separated by ,
            	String[] measuresAndValues = valuePair.split(",");
            	for(String measureAndValue : measuresAndValues) {
            		String[] measureNameAndValue = measureAndValue.split("=");
            		String subMeasureName = measureNameAndValue[0];
            		String measureValue = measureNameAndValue[1];
            		double doubleValue = Double.parseDouble(measureValue);
            		
            		GenericAggregatedMeasure subMeasure = (masterMeasure != null) ? masterMeasure.addSplitMeasure(subMeasureName, doubleValue) : addMeasure(subMeasureName, doubleValue);
            	}
            }
            
            response = "Processed " + String.valueOf(valuePairs.length) + " tuples";
	            
			return response;
		}
	 }		 
}
